

## XML

#### xml作为配置文件的优势

 当文件中配置的信息较多时,可读性好,可维护性高



#### xml概述

 XML的全称为(EXtensible Markup Language)，是一种可扩展的标记语言

 标记语言: 通过标签来描述数据的一门语言(标签有时我们也将其称之为元素)

 可扩展：标签的名字是可以自定义的,XML文件是由很多标签组成的,而标签名是可以自定义的



#### 作用

 用于进行存储数据和传输数据

 作为软件的配置文件



#### xml标签的规则

 标签由一对尖括号和合法标识符组成

 标签必须成对出现

 特殊的标签可以不成对,但是必须有结束标记

 标签中可以定义属性,属性和标签名空格隔开(属性值必须用引号引起来)

 标签需要正确的嵌套



#### xml语法的规则

```xml
<?xml version=“1.0” encoding=“UTF-8” standalone=“yes” ?>
	version：该属性是必须存在的
	encoding：该属性不是必须的
		打开当前xml文件的时候应该是使用什么字符编码表(一般取值都是UTF-8)
	standalone: 该属性不是必须的，描述XML文件是否依赖其他的xml文件，取值为yes/no
```



#### 注意事项

必须存在一个根标签，有且只能有一个

 XML文件中可以定义注释信息

 XML文件中可以存在以下特殊字符

```xml
 &lt; < 小于

 &gt; > 大于

 &amp; & 和号

 &apos; ' 单引号

 &quot; " 引号
```

 XML文件中可以存在CDATA区，CDATE区中的内容可以随便写

```xml
 <![CDATA[ …内容… ]]>
```



#### xml-DOM解析思想

 **解析:**

 从xml中获取到数据

 **DOM解析:**

 DOM（Document Object Model）文档对象模型：就是把文档的各个组成部分看做成对应的对象。

 会把xml文件全部加载到内存。在内存中形成一个树形结构，再获取对应的值

##### dom4j



### 约束

> 约束即：用来限定xml文件中,可使用的标签以及属性

#### DTD约束

**编写DTD步骤**

 1，创建一个文件，这个文件的后缀名为.dtd。

 2，看xml文件中使用了哪些元素

 <!ELEMENT> 可以定义元素

 3，判断元素是简单元素还是复杂元素。

 简单元素：没有子元素。

 复杂元素：有子元素的元素；



##### 三种引用方式

 **引入本地dtd**

 <!DOCTYPE 根元素名称 SYSTEM ‘DTD文件的路径'>

 **在xml文件内部引入**

  <!DOCTYPE 根元素名称 [ dtd文件内容 ]>

 **引入网络dtd**

```xml
 <!DOCTYPE 根元素的名称 PUBLIC "DTD文件名称" "DTD文档的URL">
 </!DOCTYPE>
```



##### DTD语法规则-定义元素

 定义一个元素的格式为: <!ELEMENT 元素名 元素类型>

 **简单元素：**

 EMPTY: 表示标签体为空

 ANY: 表示标签体可以为空也可以不为空

 PCDATA: 表示该元素的内容部分为字符串

 **复杂元素：**

 直接写子元素名称,多个子元素可以使用","或者"|"隔开；

 ","表示定义子元素的顺序 ; "|": 表示子元素只能出现任意一个

 "?"零次或一次, "+"一次或多次, "*"零次或多次;

 如果不写则表示出现一次

##### 语法规则-定义属性

 定义一个属性的格式为：`<!ATTLIST 元素名称 属性名称 属性的类型 属性的约束>`

 **属性的类型：**

 CDATA类型：普通的字符串

 **属性的约束：**

 \#REQUIRED： 必须的

 \#IMPLIED： 属性不是必需的

 \#FIXED value：属性值是固定的



#### schema和dtd的区别

1. schema约束文件也是一个xml文件，符合xml的语法，这个文件的后缀名.xsd

2. 一个xml中可以引用多个schema约束文件，多个schema使用名称空间区分（名称空间类似于java包名）

3. dtd里面元素类型的取值比较单一常见的是PCDATA类型，但是在schema里面可以支持很多个数据类型

4. schema 语法更加的复杂



#### schema

##### 编写schema步骤

 1，创建一个文件，这个文件的后缀名为`.xsd`。

 2，定义文档声明

 3，`schema`文件的根标签为：` <schema>`

 4，在`<schema>`中定义属性：

` xmlns=http://www.w3.org/2001/XMLSchema`

 5，在`<schema>`中定义属性 ：

` targetNamespace =唯一的url地址`,指定当前这个`schema`文件的名称空间。

 6，在`<schema>`中定义属性 ：

` elementFormDefault="qualified”`表示当前`schema`文件是一个质量良好的文件。

 7，通过element定义元素

 8，判断当前元素是简单元素还是复杂元素

##### 引入schema步骤

 1，在根标签上定义属性 `xmlns="http://www.w3.org/2001/XMLSchema-instance"`

 2，通过`xmlns`引入约束文件的名称空间

 3，给某一个`xmlns`属性添加一个标识，用于区分不同的名称空间

 格式为: `xmlns:标识="名称空间地址" `. 标识可以是任意的，但是一般取值都是`xsi`

 4，通过`xsi:schemaLocation`指定名称空间所对应的约束文件路径

 格式为：`xsi:schemaLocation = "名称空间url 文件路径"`

##### schema定义属性

```scheme
<attribute name="id" type="string" use="required"></attribute>

required( 必须的)

optional( 可选的)
```





## 枚举

#### 枚举-定义格式

```java
 public enum 枚举名 { 
   枚举项1,枚举项2,枚举项3;
 }
```

 **定义枚举类要用关键字enum**.



#### 枚举的特点

1.所有枚举类都是Enum的子类

2.我们可以通过`"枚举类名.枚举项名称"`去访问指定的枚举项

3.每一个枚举项其实就是该枚举的一个对象

4.枚举也是一个类，也可以去定义成员变量

5.枚举类的第一行上必须是枚举项，最后一个枚举项后的分号是可以省略的，但是如果枚举类有其他的东西，这个分号就不能省略。建议不要省略

6.枚举类可以有构造器，但必须是`private`的，它默认的也是`private`的。

   枚举项的用法比较特殊：`枚举("")`;

7.枚举类也可以有抽象方法，但是枚举项必须重写该方法

#### 枚举的方法

| **方法名**                                      | **说明**                             |
| ----------------------------------------------- | ------------------------------------ |
| String name()                                   | 获取枚举项的名称                     |
| int ordinal()                                   | 返回枚举项在枚举类中的索引值         |
| int compareTo(E o)                              | 比较两个枚举项，返回的是索引值的差值 |
| String  toString()                              | 返回枚举常量的名称                   |
| static <T> T valueOf(Class<T> type,String name) | 获取指定枚举类中的指定名称的枚举值   |
| values()                                        | 获得所有的枚举项                     |



## 注解

#### 注解的优势

 当Servlet较多时,在xml中配置比较麻烦,可以直接在类上用注解配置,简洁,方便 

#### 注解的概述

 对程序进行标注和解释

#### 注解和注释的区别

 注释: 给程序员看的

 注解: 给编译器看的

#### 自定义注解格式

```java
public @interface 注解名称 {
   public 属性类型 属性名() default 默认值 ;
}
```

**属性类型**

 基本数据类型, String, Class, 注解, 枚举, 以上类型的一维数组 

**特殊属性value**

 如果只给value属性赋值,那么value可以省略不写 

#### 元注解

**元注解：就是描述注解的注解**

| **元注解名** | **说明**                                |
| ------------ | --------------------------------------- |
| @Target      | 指定了注解能在哪里使用                  |
| @Retention   | 可以理解为保留时间(生命周期)            |
| @Inherited   | 表示修饰的自定义注解可以被子类继承      |
| @Documented  | 表示该自定义注解，会出现在API文档里面。 |

