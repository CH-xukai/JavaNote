### 继承

> 继承关键字：extends
>
> 父类、超类、基类
>
> 子类、派生类

---

#### 注意事项

子类继承父类 不能访问父类 私有的内容（权限不足）

---

#### 继承的好处和弊端

> 好处： 提高代码的复用性 
> 弊端： 加剧了代码的耦合性
> 开发中设计程序的原则： 高内聚 低耦合

---

#### 方法的重写

##### 重写和重载的区别

> - 重写: 子父类关系中，子类出现了方法声明和父类的方法*一模一样*的方法被称为方法的重写
>  - 重写时子类的方法声明不一定要和父类一模一样，子类的返回值可以是父类返回值的子类
> - 重载:  在同一个类中 方法名相同  参数列表不同  返回值类型无关
> 

##### 重写的注意事项

> - 私有的方法不能重写
>   - 是因为 子类访问不了父类的私有方法 ，访问不了 也就重写不到。 并不是 只有父类私有的子类访问不了， 父类其他权限修饰符的 的一些方法 子类也有可能访问不到。
> - 静态的方法 不能被重写
> - 子类重写父类方法权限修饰符大于等于父类方法的权限修饰符
>

---

#### 继承中的构造方法

- 子类在创建对象的时候，必须去调用父类的构造方法（语法规定）
   - 因为：子类创建对象要使用的时候，保不准就会用到父类的内容， 所以一定是先去把父类在内存中初始化
     - 如何把父类在内存中初始化？
        - 就是访问父类的构造方法，在内存中初始化。 父类初始化完了之后，子类再继续初始化子类的成员。

##### 特点

1. 继承关系中，子类的构造方法的第一个语句肯定是`super();`，子类需要先调用父类的构造方法，将父类加载，以避免在构造子类的时候会访问到父类的成员。
2. 所有的构造方法中调用其他的构造方法必须要将其他构造放在第一句。

```java
class Fu{
	public Fu(int a){
		System.out.println("Fu类有参构造方法");
	}
}

class Zi extends Fu{
	public Zi(){ 
  			super(10); // 编译成功了， 这是在手动的访问父类的有参构造
		System.out.println("zi类构造方法");
  	  		}
	public Zi(int a){ 
		super(10);// 编译成功了， 这是在手动的访问父类的有参构造
		System.out.println("zi类有参构造方法");
	}
}

				  	  	class Test{
	public static void main(String[] args){
		Zi z = new Zi();	
		/*打印内容：
			Fu类有参构造方法
			zi类构造方法
		*/
	}
}
```

---

#### 抽象类

> 有构造方法，不能用于创建实例对象，用来初始化变量
>
> 抽象类使用`abstract`修饰
>
> 一个类中如果包含抽象方法，那么这个类就必须要定义为抽象类

**特点**

> 1、抽象类不能被实例化
>
> 2、抽象类里面可以没抽象方法，但是有抽象方法的类必须是抽象类
>
> 3、普通的类继承抽象类，则必须全部重写里面的抽象方法。



### 权限修饰符

| 修饰符    | 同一个类中 | 同一个包中，子类无关类 | 不同的包的子类 | 不同包的无关类 |
| --------- | ---------- | ---------------------- | -------------- | -------------- |
| private   | √          |                        |                |                |
| 默认      | √          | √                      |                |                |
| protected | √          | √                      | √              |                |
| public    | √          | √                      | √              | √              |

